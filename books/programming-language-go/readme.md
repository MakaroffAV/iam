[Алан Донован - Язык программирования Go](https://disk.yandex.ru/i/hTlIdUWe8z_IYQ)

## План изучения

|    Дата    |  Страницы  |
|------------|------------|
| 12-06-2024 | 0-44       |
| 13-06-2024 | 44-88      |
| 14-06-2024 | 88-132     |
| 15-06-2024 | 132-176    |
| 16-06-2024 | 176-220    |
| 17-06-2024 | 220-264    |
| 18-06-2024 | 264-308    |
| 19-06-2024 | 308-352    |
| 20-06-2024 | 352-396    |
| 21-06-2024 | 396-440    |


## Процесс изучения 

- 12-06-2024
    -   Пропущена работа с gif
        1.  бесполезно,  имхо
        2.  работает медленно
        3.  огромный объем gif

    -   Выборка URL
        *   e8.go
        *   ./t5/
            *   Выборка URL, чтение через io.Copy
        *   ./t6/
            *   Выборка URL, добавление https:// при отсутствии
        *   ./t7/
            *   Выборка URL, вывод кода состояния ответа

    -   Параллельная выборка URL
        *   e9.go
        *   ./t10/
            *   Исследование работы кэширования и сохранение результатов запроса в файл
            *   Первый ответ 0.09, второй 0.06. Там есть кэширование, но видимо сайт под постоянной нагрузкой и первый ответ есть результат работы кэширования
        *   ./t11/
            *   Дублирование параллельной выборки, не знаю сайт, который не отвечает. Но судя по всему там будет ждать бесконечно вывод из канала, в который пишется результыть запросы к сайту, который не отвечает
    -   Веб-сервер
        *   e10.go
        *   e11.go
        *   e12.go
        *   ./t12/
            *   Передаем в параметры анимации как аргументы GET запроса 
- 13-06-2024
    -   Объявление типов
        *   ./ch2/e1
            *   при сравнении необходимо учитывать не только сравниваемые значения, но и их типы
            *   преобразование между типами возможно только в том случае, если оба они имеют один и тот же базовый тип или оба они являются неименованными указателями на переменные одного и того же базового типа. Такое преобразование изменяет тип, но не значение
    -   Пакеты и файлы
        *   Без сенсаций, заглавная буква - можно экспортировать, маленькая - нет
        *   ./ch2/t1
    -   Импорты
        *   В самом начале по пути, который go mod init <путь>
        *   Импорт без последующего его использования считается ошибкой
    -   Инициализация пакета
        *   В самом начале инициализируем переменные уровня пакета
        *   Инициализацию пакета можно еще определить через функцию init()
        *   Область видимости - это область исходного текста программы; это свойство времени компилции
        *   Время жизни переменной - диапазон времени выполнения программы, когда к переменной можно обратиться из другой части программы; это свойство времени выполнения
    -   Фундаментальные типы данных
    -   Целые числа
        *   Есть знаковые и беззнаковый целочисленные типы (int8, int16, int32, int64), а также беззнаковые их версии (uint8, uint16, uint32, uint64)
        *   8, 16, 32, 64 - размеры этих типов
        *   int, uint - зависят от ОС, естественный и наиболее эффективный размер для этих ОС
        *   Бинарные операторы GO (в порядке уменьшения приоритета)
            -   *  (умножение)
            -   /  (целочисленное деление)
            -   %  (остаток от деления)
            -   << (сдвиг влево)
            -   >> (сдвиг вправо)
            -   &  (побитовое И)
            -   &^ (сброс бита, И НЕ); z = x &^ y, каждый бит z равен 0, если соотв бит равен 1, иначе 1
            -   +  (сложение)
            -   -  (вычитаение)
            -   |  (побитовое или)
            -   ^  (побитовое исключающее или)
            -   == (равно)
            -   != (не равно)
            -   <  строго меньше
            -   <= (меньше или равно)
            -   >  (строго больше)
            -   >= (больше или равно)
            -   && (логическое и)
            -   || (логическое или)
        *   +x ~ 0 + x, -x ~ 0 - x, для целых
        *   +x ~ x > 0, -x ~ x < 0, для чисел с плавающей точкой и комплексных чисел
    -   Числа с плавающей точкой
    -   Комлексные числа
    -   Булевые значения
    -   Строки
        *   Строка предствляет собой неизменяемую последовательность байтов
        *   Традиционно строки интепретируются как последовательность символов Unicode в кодировке UTF-8
        *   len(str) возвращает кол-во байтов в строке, не символов!!!
        *   str[i:j] дает новую строку, состоящую из байтов исходной строки, начиная с i и до (не включая) байта с индексом j; содержит j-i байтов
    -   Строковые литералы
        -   \a (звуковой  сигнал)
        -   \b (забой, backspace)
        -   \f (перевод страницы)
        -   \n (новая строка)
        -   \r (возврат каретки)
        -   \t (табуляция)
        -   \v (вертикальная табуляция)
        -   \' одинарная ковыяка (только в литералах '...')
        -   \" двойные   ковычки (только в литералах "...")
        -   \\ обратная косая черта
    -   Unicode
        *   ASCII american standart code for information interchange
        *   7 бит для предоставления 128 символов
    -   UTF-8
        *   от 1 до 4 байт для предоставления каждой руны (1 для ascii и 2, 3 байта для других распространенных рун)
- 14-06-2024
    -   Массивы
        *   Массив представляет собой последовательность фиксированной длины из нуля или более элементов определенного типа
        *   ./ch3/e1
        *   По умолчанию элементам новой переменной массива изначально присваиваеются нулевые значения типа элемента. Кроме того, для инициализации массива списком значений можно использовать литерал массива
        *   Если в литерале массива на месте длины находится троеточие, то длина массива определяется количеством инициализаторов, q := [...]int{1, 2, 3}
        *   Можно задать массив, как список пар "индекс - значение" symbol := [...]string{USD: "$", EUR: "€", GBP: "£", RUR: "₽"}
        *   В этом случае индексы могут появляться в любом порядке, а некоторые из них могут быть опущены. Неуказанные значения получают нулевое значение типа элемента, например: r := [...]int{99:-1} определяет массив r со ста элементами, среди которых ненулевым является только последний элемент, значение которого равно -1
        * Если тип элемента массива является [сравниваемым](https://www.google.com/url?sa=i&url=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F34245932%2Fchecking-equality-of-interface&psig=AOvVaw2-HmiZmjqSdzBzSUEIjyJS&ust=1718438089390000&source=images&cd=vfe&opi=89978449&ved=0CBEQjRxqFwoTCJi22PDO2oYDFQAAAAAdAAAAABAE), то таким же является и тип массива, так что мы можем сравнить два массива такого типа непосредственно, с помощью оператора ==, который сообщает все ли соответствуюшие элементы массивов равны. Причем они должны быть равны не только по значениям, а по паре "индекс - значение"
    -   Срезы
        *   Срезы представляют собой последовательности переменной длины, все элементы которых имеют один и тот же тип. Тип среза записывается как []T, где T - тип элементов среза
        *   Массивы и срезы тесно связаны, срез - это легковесная структура данных, которая предоставляет доступ к подпоследовательности элементов массива, извесного как базовый массив. Срез состоит из трех компонентов: указателя, длины, емкости. Указатель указывает на первый элемент массива, длина - кол-во элементов среза. Длина не превышает емкость
        *   Несколько срезов могут совместно использовать один и тот же базовый массив и относиться к перекрывающим частям этого массива
        *   Оператор среза s[i:j], где 0 <= i <= cap(s). i или j может быть опущено, более того и i, и j может быть опущено
        *   Срезание за пределами cap(s) вызывает аварийную ситуацию, а срезание за пределами len(s) приводит к расширению среза
        *   ./e2
        *   Поскольку срез содержит указатель на элемент массива, передача среза в функцию позволяет изменять элементы базового массива
        *   Срезы не являются сравниваемыми, поэтому мы не можем использовать оператор ==
        *   Для ссылочных типов, таких как указатели и каналы, операторы == проверяют ссылочную тождественность, те ссылаются ли две сущности на один и тот же объект
        *   Единственным разрешенным сравением среза является сравнение с nil
        *   Чтобы проверить является ли срез пустым: len(s) == 0, а НЕ len(s) == nil
        *   Загадка про make([]int, len, cap). Делает массив, но возвращает срез на него. Срез заключается только представлением первых len его элементов. Но емкость включает в себя весь массив
    -   Функция append
        *   ./e3
        *   Аллоцирует 2x памяти при расширении
    -   Работа со срезами "на месте"
        *   ./e4
    -   Отображения
        !!! стр 123 - 210 пропущены !!!

    -   Интерфейсы
        *   Интерфейс является абстрактым типом
        *   Он не раскрывает представление или внутреннюю структуру своих значений, или набор основных поддерживаемых ими операций; он покатывает только некоторые из их методов

        !!! стр 210 - 258 пропущены !!!

    -   Go-подпрограммы
        *   ./ch8/e1
        *   В go каждая одновременно выполняющаяся задача называется go-подпрограммов
        *   ./ch8/e2
        *   Вызов горутины происходит с использованием ключевого слова go. go example_func(). После вызова example_func() продолжает работать как отдельная подпрограмма, а сама по себе инструкция go немедленно завершается
        *   Канал представляет собой механизм связи, который позволяет одной go-подпрограмме отправлять некоторые значений другой go-подпрограмме. Каждый канал является средство перездачи значений определенного типа
        *   Канал является ссылкой на структуру данных
        *   Канал имеет две основные операции, получение и отправление
            -   ch <- x  // отправление
            -   x = <-ch // получение + присваивание
            -   <-ch     // получение без присваивания
        *   Канал может быть буферизированный и небуферизированный
            -   ch = make(chan int)    // небуферизированный канал
            -   ch = make(chan int, 0) // небуферизированный канал
            -   ch = make(chan int, 3) // буферизированный канал, емкость 3

    -   Небуферизованные каналы
        *   ./ch8/e3
        *   Операция отправления в небуферизированный канал блокирует go-подпрограмму до тех пор, пока другая go-подпрограмма не выполнил получение из того же канала
        *   Если первой сделана попытка выполнить получение, принимающая go-подпрограмма блокируется до тех пор, пока другая go-подпрограмма не выполнит отправления значения в тот же канал

    -   Однонаправленные каналы
        *   ./ch8/e4
        *   тип chan <- int преставляет собой канал int, предназначенный только для отправления, который позволяет отправлять данные в канал, но не получать из него
        *   тип <- chan int представляет собой канал int,
        предназначенный только для чтения данных из канала
        *   Нарушение применения таких каналов обрануживаются во время компиляции

    -   Буферизованные каналы
        *   Буферизированный канал имеет очередь элементов. Максимальный размер очереди определяется при создании канала с помощью аргумента емкости функции make.
        *   ch = make(chan string, 3) // создает буферизированный канал, способный хранить три строковых значения
        *   Операция отправления в буферизированный канал вставляет отправляемый элемент в конец очереди, а операция получения удаляет первый элемент из очереди
        *   Если канал заполнен, операция отправления блокирует свою go-подпрограмму до тех пор, пока другая go-подпрограмма не освободит место, получив данные из канала
        *   Если канал пуст, операция чтения блокирует свою go-подпрограмму до тех пор, пока в канал не будет послано значение

    -   Select, WaitGroup